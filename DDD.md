# DDD 도메인 주도 설계   
> Domain-Driven-Design   

소프트웨어의 복잡성을 낮추는 기술 중 하나     
소프트웨어가 복잡한 이유는 **도메인이 복잡하기 때문이다.**        
         
우리는 도메인을 올바르게 표현하고 관리할 방법을 알아야하는데           
그렇지 않고 '이 기술을 사용하면 소프트웨어의 복잡도를 낮출 수 있는데'라면서 착각을 한다.           
즉, 기존 도메인이 올바르게 표현되지 않았는데 이것에 대한 복잡도를 낮추기 위해 디자인 패턴과 같은 기술을 사용하고자 한다.             
         
예를 들면 머신러닝을 활용했을 때 여러 패턴들을 사용해서 복잡도를 낮춘다 하더라도 이는 한계가 있다.           
왜? 머신 러닝 자체가 복잡하고 내부 로직을 개선해야지만 그 복잡도가 낮아지니까.(이를 위해서 수학 필요)               
다른 예로 회계 프로그래밍을 작성한다 치는데 복잡성이 높다. 왜? 회계가 복잡하니까.     
    
여기서 도메인 주도 설계는 **기존 도메인의 복잡성을 개발자가 도메인 전문가와 함께하여 복잡성을 낮추는 설계**이다.          
즉, 도메인을 나타내는 **요구 사항 명세서의 복잡성을 해결**하기 위해 **개발자와 도메인 전문가가 함께하여 표준을 만들고 복잡성을 낮추는 것**이다.         
그리고 이 과정에서 `도메인/모델/구현`에서 공용(표준)으로 사용될 **유비쿼터스 랭귀지**도 만든다.         
예를 들면 `스위치 - 전원 스위치/닌텐도 스위치 등..`와 같이 이름이 같지만 다른 개념들을            
하나의 컨텍스트(클래스)로 만드는 것이 아니라 각각의 `class 게임_스위치`, `class 전원_스위치`와 같이 만드는 것이다.              
이런 컨텍스트들을 각각의 그룹이나 바운드 컨텍스트에 따로 따로 넣어 주는 설계법을 도메인 주도 설계라고 한다.           
       
**총 정리 :**       
도메인이 복잡하면 코드가 복잡해진다.              
이 때문에 기존 복잡한 도메인을 그대로 사용하면 다양한 디자인 패턴을 사용하더라도 한계가 있다.     
그렇기에 도메인의 복잡성을 낮추기 위해 개발자와 도메인 전문가와 협업하여 설계하는 것이고 
이 과정에서 유비쿼터스 랭귀지를 만들고 각각의 바운드 컨텍스트에 알맞은 컨텍스트를 넣어준다. (게임-스위치, 건설-스위치)     
그리고 이러한 도메인의 복잡성을 낮추기 위해 개발하는 모든 과정을 도메인 주도 설계라 한다.

# 목차    

1. Domain, DDD(Domain Driven Design)란?    
2. 왜 도메인 주도 설계인가?    
3. DDD의 전략적, 전술적 패턴   

# DDD 도메인 주도 설계  
> 도메인이 복잡하면 코드가 복잡해진다.     
    
**도메인 :**    
* 사용자가 사용하는 것, 소프트웨어로 해결하고자 하는 문제        
* 비즈니스 영역에서 처리하고자 하는 대상을 의미            
* **우리가 아는 URL 도메인을 이야기하지는 않는다.**         

**도메인 주도 설계**    
* 도메인을 중심으로 하는 개발 방식
  * 기존 도메인을 그대로 놔두고 다양한 디자인 패턴을 이용하여 복잡성을 낮추는 것이 아니라!!!
  * **기존 도메인 자체의 복잡성과 문제점들을 해결하기 위해 도메인을 중점으로 개발하는 방식**       
  * 즉, 복잡한 도메인을 해결하는 것을 높은 우선순위로 생각해 서비스를 만들어 나가는 방법      

<img width="827" alt="스크린샷 2020-11-19 오후 10 36 46" src="https://user-images.githubusercontent.com/50267433/99673861-9c538380-2ab8-11eb-8b60-a0aefbf43a43.png">  
    
* 소프트웨어 개발 프로세스 과정은 위 그림과 같다.      
* 도메인       
  * 추상화
* 모델
  * 실체화   
* 소프트웨어  
   
   
<img width="830" alt="스크린샷 2020-11-19 오후 10 39 47" src="https://user-images.githubusercontent.com/50267433/99673946-b7be8e80-2ab8-11eb-8566-f1949e81ff6f.png">   
  
* 개발 프로세스의 영역을 나누면 위 그림과 같다.      
* 도메인 전문가 : 도메인을 통한 모델 개발     
* 개발자 : 모델을 통한 소프트웨어 개발    
* 여기서 중요한 점은 개발자는 기존 만들어진 모델을 통해서 소프트웨어를 구현하는 것이다.   
    
<img width="832" alt="스크린샷 2020-11-19 오후 10 41 53" src="https://user-images.githubusercontent.com/50267433/99673994-c5741400-2ab8-11eb-96c5-a60fc554987f.png">  
     
* 개발자는 단순히 기존 모델을 코드로 구현을 하는 것이기에 본래의 목적과 의도를 누락하면서 코딩을 할 수 있다.      
* 왜냐하면 모델링에 참여하지 않았기에 해당 모델에 대한 이해가 부족하며 실제 도메인과 차이점이 발생할 수 있다.     
* 그럼에도 다수의 개발자는 모델을 이해하지 못한 상태로 단순히 기술적으로만 복잡도를 낮추려는 현상이 벌어지고 있다.        
* 이를 해결하기 위해 DDD가 등장했으며 2가지 방법이 제시되었다.
  * 유비쿼터스 랭귀지
  * 모델 주도 설계   

```
우선 도메인 주도 개발은  
각 전문가 마다 나눠진 분야를 하나로 통합해서 각각의 전문가들끼리 소통을 하며 협업을 이끌어내는 과정이라 생각하면된다.   
협업하는 과정에서 용어 표준, 모델링 설계등을 개선하여 도메인을 보다 쉽게 구현하는 것이라 생각하면 된다.       
```  

## 유비쿼터스 랭귀지(보편언어)
* 도메인에 대한 어휘를 이해관계자(도메인 전문가, 개발자, 분석가..)들이 공통적으로 의미를 이해할 수 있도록 정의하는 것   
* `요구 사항 분석 명세서` -  `모델` - `코드`에서 서로 같은 것을 지칭하지만 용어가 다를 수 있다.   
* 이를 공통된 하나의 용어로 맞춤으로써 여러 용어를 관리해야한다는 복잡성을 낮출 수 있다.  

**나쁜 예시**  
```  
개발자 : Routing 서비스에 출발지, 도착시간을 입력하면 화물이 멈춰야 할 지점을 찾고 데이터베이스에 저장한다. (모호하고 기술적임)
도메인 전문가 : 무슨 소리야?    
```   
**좋은 예시**  
```  
개발자 : Routing 서비스는 Route Specification을 만족하는 Itenrary를 찾는다.
한국어 번역 : 전송 서비스는 전송 명세서를 만족하는 곳을 찾는다.
도메인 전문가 : 오케이 알겠어!
```   
    
## 모델 주도 설계         
* 분석과 설계를 나누지 않으며 분석/설계/구현의 모든 단계를 관통하는 하나의 모델을 사용하고 이를 유지합니다.   
  * 즉, 분석과 설계 그리고 구현마다 다르게 사용되는 모델을 두는 것이 표준 모델을 만들어 사용합니다.   
* 모델링 통해 기존 도메인의 목적과 의도와 같은 내용들을 코드에도 적용합니다.        
* 반대로 코드에서 발생할 수 있는 문제점을 모델에 반영할 수도 있어야합니다.      
* 모델 == 코드       
  * 표준화된 모델을 기반으로 코드를 작성합니다.   
  * 모델이 바뀐다면 코드가 바뀌고 코드가 바뀌면 모델이 바뀌어야 한다.     
     
### 도메인 모델     
* 도메인에 대한 구체적인 설계, 도메인을 개념적으로 표현한 것  
  * 도메인을 분석하고 이를 모델로 설계한 것 
* 개념들의 관계를 표현한 모델            
* 문제 영역을 시각화         

## 도메인 주도 설계 - 복습  
* 복잡한 소프트웨어는 기술 자체의 복잡성 보다는 도메인 자체의 복잡성에 기인  
  * 즉, 코드가 복잡한 것은 기술 문제가 아닌 도메인 자체가 복잡하기 때문이다.   
  * 도메인을 가장 잘 아는 사람(도메인 전문가)과 어떻게 협업할 것인지가 가장 중요 (복잡성을 낮추는 방법)      
  * 유비쿼터스 랭귀지, 모델 주도 디자인 2가지 기능을 가지고 복잡성을 낮추고 있다.       

# 등장 배경    
* 모델링과 개발과의 불일치      
  * 앞선 얘기했던 내용   
  * 도메인을 모르고 개발하니 진짜 목적과 의도를 모르고 개발할 가능성 있음     
  * 공통된 모델과 용어가 없으니 개발시에 신경써야할 것이 많아지고 복잡성이 증대될 수 있음   
* **데이터에 종속적인 애플리케이션**       

## 데이터 중심적인 접근법   
* 기존 개발은 DB 테이블 중심   
  * JPA를 사용하기 이전에는 DB에 맞춰서 클래스를 작성해야하는 의존적인 형태였다.    
* **빈약한 도메인 모델 - 아래에서 설명**   
    
## 빈약한 도메인 모델
* Getter 와 Setter만으로 구성 된 모델
  * 도메인 객체들에 비즈니스 로직이 거의 없거나 아예 없는 소프트웨어 도메인 모델     
  * 객체 지향의 목적과는 달리 단순히 `getter/setter` 로직만 존재할 경우 이를 빈약한 도메인 모델이라 한다.   
    * 객체 지향이란 데이터와 프로세스를 함께 묶는 것이다.       
    * getter/setter만 존재하는 것은 비즈니스 로직은 전혀 없고 단순히 값만 넣고 빼므로 절차 지향과 크게 다를바가 없기 때문이다.     
    * 더 정확히 말하면 객체 지향 모델링 과정에서 모델링 설계를 잘못해서 일어난 결과라고 봐도 무방하다.   
* 데이터만 가지는 데이터홀더 개념 
  * 정보은닉만 사용하여 데이터를 메서드로 넣고 빼기만 하는 홀더 개념만 가진다.    
* Big Service Layer    
   
-> 모델과 구현(코드)의 불일치가 발생, 소통의 어려움   

# DDD OverView   
  
![DDD-Pattern-Language-Overview-sml_divide](https://user-images.githubusercontent.com/50267433/99480749-1215fd00-299c-11eb-97e4-bfdc7c45b6c9.png)    
   
   
* 전략적 설계 
  * 개념 설계  
* 전술적 설계   
  * 구체적 설계   
  
## 전략적 설계  
* 복잡한 도메인의 맥락(Context) 경계를 명확히 정의하는 과정    
* Bounded Context 안의 도메인 모델에서 보편 언어를 개발하는 방법  
  * 도메인에 집중하면 도메인이 설명하는 범위와 도메인 간의 경계들이 명확하게 드러나는데, 이를 Bounded context라고 합니다.    
* 도메인에서 서브 도메인으로 복잡성 분리   
  * 핵심, 지원 도메인 파악 - 관점 파악 -> AOP의 근간?    
* 컨텍스트 맵핑 기술을 활용해 여러 개의 Bounded Context 통합   
* 이벤트 스토밍 기법을 활용해 Bounded Context 식별   
    
### 진흙 덩어리 문제   
   
[사진]    
   
## 전술적 설계    
* 전략적 설계에서 더 상세한 부분(바운디드 컨텍스트 내부)모델링   
* Model Driven Design - MDD   
* 빌딩 블록(패턴)을 사용해 모델링 - Aggregate 패턴    
* 계층형 아키텍처를 통한 도메인 모델 분리   
* 도메인 이벤트를 통해 도메인을 보다 명확히 모델링  
 
### 전술적 설계 Building Block   
[사진]  
[사진]   
[사진]
 
# DDD 결론  
* 흔히 DDD를 떠올리면 DDD의 전술적 설계에 대한 개념을 많이들 떠올립니다.(Entity, ValueObject, Aggregate)     
* 물론 DDD의 전술적 설계만 했을 시에도 장점 존재 - DDD Lite        
* 하지만 DDD는 이러한 패턴보다는 협업을 통한 문제 해결이 더 강조        
  

# 개인적인 생각으로는 
같은 뜻을 가진 여러개의 개념을 한개의 클래스로만 표현하지 않고   
각각의 클래스로 만들어 활용하는 것이라 생각한다.  
 

* 예를 들면 아래와 같다.  
  * 이름은 같지만 다른 역할
    * 카탈로그 도메인 : 상품(상품 이미지, 상품명, 가격)
    * 재고 관리 도메인 : 상품(실존하는 개별 객체를 추적 목적)
  * 이름은 다르지만 같은 역할
    * 회원 도메인 : 회원
    * 주문 도메인 : 주문자
    * 배송 도메인 : 보내는 사람
* 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에       
한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니다.    
  * 예를 들면 '상품'을 기준으로 카탈로그 도메인과 재고 관리 도메인을 표현하는 것은 올바른 방법이 아니다.
* 하위 도메인마다 모델을 만들어야 한다.
  * 카탈로그 상품 도메인과 재고 관리 상품 도메인을 각각 만들어야 한다.   
* 각 모델은 명시적으로 구분되는 경계를 가져서 섞이지 않도록 해야 한다.
  * 카탈로그 / 재고 관리
  * 이를 bounded Context라 한다.   
* 섞이기 시작하면 모델의 의미가 약해질 뿐만 아니라 하위 도메인 별로 다르게 발전하는 요구사항을 모델에 반영하기 어려워진다.
  * 상품에서 나눠지는 것이 아닌 각 분야마다 따로 만들어주어야 복잡성이 낮아진다.       
 
 
 
# 참고 
블로그   
https://nesoy.github.io/articles/2018-07/DDD-Bounded-Context  - boundedContext      
https://ppiyo5.tistory.com/21 - 나중에 보면 좋을 것 같아서.    
https://opennote46.tistory.com/193 - 유비쿼터스 랭귀지   
https://m.blog.naver.com/PostView.nhn?blogId=loopbit&logNo=221319258228&proxyReferer=https:%2F%2Fwww.google.com%2F 참고     
https://m.blog.naver.com/PostView.nhn?blogId=muchine98&logNo=220304821784&proxyReferer=https:%2F%2Fwww.google.com%2F - 도메인 모델   
