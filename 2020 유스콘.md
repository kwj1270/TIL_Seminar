# 오후 2:00 ~ 2:20: 주니어 개발자 이직기
👨‍💻 컴공돌이

💬 학생 때 인턴 시작부터 스타트업에 첫 취업을 하게 되고 이직을 결심하게 된 계기부터,     
어떻게 일과 병행하면서 공부와 이직 준비를 하였는지,    
퇴사는 어떻게 하였는지를 공유합니다.    
또 이직 후 어려웠던 점이나,    
전 회사에서 내가 성장했다고 알게 되었던 점 등을 소개합니다.    
    
## 내용  
### 자기소개       
컴공 돌이 : cafemug        
백엔드, 데이터 엔지니어, DevOps 개발자    

### 이직 준비
회사의 장점
1. 워라밸 우수 
2. 일의 과부화가 없음 
3. 사람들이 너무 좋음 
4. 출퇴근 시간 자유로움   
5. 개발 문화 및 사수 실력의 우수성
6. 괜찮은 연봉     

퇴사 결심 이유  
1. 백엔드 개발자로서의 성장 가능성이 안보임 
2. 데이터 분석팀에 의존한 개발팀     
3. 사수가 한 명임, 즉 코드 리뷰, 케어가 없음   
4. 네임벨류가 떨어짐 feat 안정성     
5. 복지는 없음    
     
목표 우선 순위 정립    

**초반**
1. 연봉 
2. 네임밸류 
3. 성장 가능성 
4. 워라밸 
5. 사람들이 좋은지 
6. 복지 

**후반**
1. 성장 가능성 
2. 무슨 일을 하는지 
3. 사람들이 좋은지 
4. 연봉 
5. 워라밸 
6. 복지 

**준비 깨알 팁**   
1. 알고리즘과 포트폴리오는 평소에        
2. 자기 분야의 최신 정보 follow up          
3. 면접 준비는 자신감 feat.모의 면접           
4. 휴가를 잘 써보자 feat.병가 (이직 테스트 날)             
5. 퇴직은 어떻게 하는게 좋은가? 
    1. 퇴사는 한달 전에 통보 (법)
    2. 못나가면 어떻게 하지 고민 X  
    3. 나 없으면 회사가 안돌아가 고민 X 
    4. 인수인계는 확실히 O - 문서화 

### 회사 말고 자기 개발
1. 해커톤과 같은 대외적인 활동 중요       
2. 멘토링 및 교육활동 (강연, 봉사등도 있음)   
3. 1일 1 커밋  
4. 주중 : 알고리즘, 언어공부 
   주말 : 해커톤, 개인 프로젝트 
5. 외주 & 개인 프로젝트  

### 회사 적응
**좋았던 점**
1. 전 회사의 개발 문화 굳
2. 기획자 소통과 기획리뷰 경험
3. TDD경험 & 코드리뷰  
4. 개발과 공부에 집중할 수 있는 환경  

**어려웠던 점**
1. 기간 산정의 어려움  
2. 기존 프로젝트 파악의 어려움 (사내 문서, 개발자들에게)     
3. 사람들과 친해지기    

### 마무리
1. 현재 회사에서 퇴사를 하려는 이유를 명확히 파악 및 장단점 비교! 
2. 공부는 평소에, 퇴사 마음이 든다면 더 빡세게 
3. 언젠간 다시 볼수 있으니 퇴사도 매너 있게!  
4. 회사에서 배운건 자기도 모르게 도움이 됨
5. 자기한테 100퍼센트 만족스러움


# 오후 2:30 ~ 2:50: MySQL Isolation, Lock 
👨‍💻 오길환

💬 친구가 개발하고 있는 예약 사이트 코드 리뷰 중 발견한 문제점!        
하나의 물건을 여러 명이 예약이 가능했다...!        
해당 문제를 해결하기 위해 간단히 적용한 lock에 대해서 알아보고,        
나아가서 isolation에 대해서 간단히 알아봅니다!    

## 내용
### Isolation
- 트랜잭션의 격리수준
- A 트랜잭션이 B트랜잭션에서 변경한 데이터를 볼 수 있도록 허용함
### Isolation
- 강력한 일관성, 높은 비용 
### Read_UNCOMMITTED   
커밋 전의 데이터 변경 내용을 다른 트랜잭션이 읽는 것을 허용  
- 더티 리드 : 롤백시 변경이 되지 않은 코드로 다시 사용됨      
### 논리피터블 리드 
트랜잭션 내에서 조회한 내용이 항상 동일하지 않은 현상    
### 리피터블 리드 
트랜잭션 내에서 조회한 내용이 항상 동일한 결과를 표출      
  - 문제점 : 팬텀리드 : 트랜잭션 내에서 이전에 조회한 결과에 없던 새로운 레코드가 나타나는 현상 

### Serializable
트랜잭션이 일고있는 데이터를 다른 트랜잭션에서 수정 추가 불가능
문제점 : 성능 저하 - 오토커밋이 off이면 락이 걸려서   

### Lock
Lock이란 ?  : 트랜잭션이 데이터에 접근할 때, 다른 트랜잭션이 데이터에 접근하지 못하게 함  

Shared Lcok : 공유잠금
Exclusive Lock : 배타잠금 : UPDATE,DELETE,FOR UPDATE 등이 불가능해짐    

### QNA
리얼 MYSQL 추천  


# 오후 3:00 ~ 3:20: 하반기 채용에 깨진 멘탈 다시 붙인 썰
👨‍💻 최장훈(가천대학교)

💬 뜨거운 하반기 채용에 치즈 퐁듀처럼 녹은 멘탈,  
'이것'을 통해 복구하다? 발표 내용은 백기선님 자바 스터디 후기이지만,  
스터디하면서 변화된 것을 중점적으로 발표합니다.   
발표 대상은 하반기 채용에 실패해서 무엇을 할지 모르는 사람들,  
스터디 참여를 망설이는 사람들,   
무엇을 해야 할지 갈피가 잡히지 않는 사람들입니다.

## 내용
* 단기적인 목표가 간절히 필요한 분     
* 시작하는 것을 망설이는 습관을 개선하고 싶은 분     
* 좋은 습관을 갖추기 위해 도전하고 싶은 분      
        
### 하반기 채용 도전기
* 처음 목표는 토익 스피킹/자격증 취득  
* 이상 - 서류는 늘 합격하는 멋쟁이라 생각, 현실 - 서류도 늘 합격 못하는 나 
* 멘탈에 금이가기 시작 
* 그래도 이렇게 살면 안되겠다.
* 번아웃 때문에 힘듬 --> 집중할 수 있는 단기적 목표가 필요하다.   
* 백기선님의 온라인 자바 스터디를 나의 목표로 잡자    

### 스터디 참여하면서 생긴 변화     
1. 목표가 생기고 동기가 생기므로 내 생활패턴이 달라진다.     
2. 가독성이 높게 정보를 정리하고 기록하는 습관에 도전한다.       
3. 코딩습관 개선에 도전하다. (설계를 얕게 하지 말자)      
     
10분 생각 50분 코딩이 아닌    
50분 생각 10분 코딩     
        
전체적인 흐름파악이 쉬워짐         
발생가능한 예외사항 예측        
실수 감소 = 코딩 스트레스 감소      

# 오후 3:30 ~ 3:50: 어디 가서 코틀린 알은체하기

👨‍💻  박재성(Jason)(우아한형제들) 

## 내용
### 코틀린 
* JVM, Android, JavaSCript 및 Native를 대상으로 하는 정적 타입 지정언어   
* 젯브레인에서 개발 
* OO 및 FP 혼합해서 사용

### 정적 타임 지정 언어
* 컴파일러가 타입 추론을 통해서 어떤 타입인지 판단하는 것 
* `var x: Int = 1`
* `var x = 1`
* 프로그래머가 타입을 선언해야 함에따라 생기는 불편함이 대부분 사라진다.   
* 세미콜론도 안 붙여져 있다.   

### 얼마나 사용하고 있나요?  
* 지난 12개월 동안 580명 이상의 사용자가 사용 
* 상위 5개 언어
* 구글이 지정한 안드로이드 공식 언어
* 스프링 5.2 부터 코틀린 코드 샘플도 제공  
* 완성형 언어에 가까워진다.   
   
### 멀티 플랫폼 지원   
* JVM에서 돌아가는 언어뿐만 아니라 , Javascript, 자체 네이티브 환경에서도 돈다.    
* 코틀린 1.3 이전까지는 일관된 랜덤 생성 방법이 없어 각 플랫폼별 솔루션에 의존     
* 1.3부터는 코틀린 램덤 클래스가 생겨서 사용가능 
* 즉, 이전 코드를 그대로 가져와 사용해도 문제가 없어졌다.   

### 코틀린/JVM
* 내부적으로 애플리케이션이 실행되기 시작하면 코틀린 컴파일러는 모든 코틀린 파일을 JVM이 이해할 수 있는 자바 바이트 코드로 변환 
* 결국 코틀린이 아닌 JVM에서 실행되는 바이트코드이다.  
* 코틀린 컴파일러가 코틀린 파일을 해석해서 클래스 파일로 변환
* 자바 파일도 자바 컴파일러가 자바 파일을 해석해서 클래스 파일로 변환  
* 그런데 롬복은 왜 안돌아갈까?    
* 코틀린 컴파일 과정에서 나타난다.
* 롬복의 코드를 생성하는 단계는 어노테이션 프로세스 단계이다.  
* 코틀린 코드는 롬복이 생성한 코드를 사용할 수 없다.  
* 그러면 자바 컴파일을 우선순위로 순서를 바꾸면 되지 않을까?  
* 그러면 자바 코드에서 코틀린 코드를 사용할 수 없다.
* 그렇다면 롬복 포기? : 네 포기해야합니다. 없어도 좋은 퍼포먼스를 보여줍니다.   

### 모든 것이 객체
* 코틀린은 모든 것이 객체
* 일부 유형은 특수 내부 표현을 가질 수있다.    
일반 자료형 타입도 기본 값으로 표시될 수 있지만 사용자에게는 일반 클래스처럼 보임     

```java
val a: Int = 100
val boxedA: Int? = a
val anotherBoxedA: Int? = a

println(boxedA == anotherBoxedA) // true;
```

### 코드   
함수를 최상위 수준에 정의할 수 있다.
사실 뒤에 클래스가 숨어있지만 보지 않는것
Java와 달리 꼭 클래스 안에 함수를 넣어야할 필요가 없다.  
메서드가 아닌 함수라는 말을 사용한다.   

```kt
fun main() {
    println("Hello, world!")
}
```

### 변수 선언 
코틀린은 2가지 키워드 val 및 var를 사용하여 변수를 선언
불변되는 변수 :  `val`
변경될 수 있는 변수 : `var`

### 스마트 캐스트
* 코틀린에서는 프로그래머 대신 컴파일러가 캐스팅    
* 어떤 변수가 원하는 타입인지 검사하고 나면 굳이 변수를 원하는 타입으로 캐스팅하지 않아도 마치 처음부터 그 변수가 원하는 타입으로 선언된 것처럼 사용할 수 있다.  
* 실제로는 컴파이럴가 캐스팅을 수행해 주며 이를 스마트 캐스트라고 부른다.   

### 이름 붙인 인자   
```kt
Person("박재성", 29, "제이슨")
```

### 널타입  
`?`를 붙여주면 nullable한 타입이 된다.        
널러블한 변경에 대해서만 붙여주면 된다.   

### 유틸리티 클래스  
주로, 정적 메서드를 가진 클래스    
이런 클래스를 만드는 대신에 최상위 함수를 만들어 사용하면 된다.      
즉, 함수를 최상위 수준으로 빼서 최상위에서 사용해도된다.      
클래스를 따로 만들지 않아도 된다.      

### require(), check
require()는 값을 만족하지 않으면 IllegalArgumentException을 발생   
check()는 값을 만족하지 않으면 IllegalStateException을 발생    

### API가 깔끔하다.   
* 읽기 쉽다.  
* 외관이 보기 좋다.  
* 간결하다. 

